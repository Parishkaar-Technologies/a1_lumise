hi, now that my two customizations are done, shall we work on applying lineset features to dot grids, reusing most of the scaffolding we did. 

For Linesets, What I have right now are these:

UI Part for linesets: 

<div id="a1_edit_form" style="display: none; position: fixed; top: 100px; left: 5%; width: 320px; background: #fff; border: 1px solid #ccc; padding: 16px; border-radius: 8px; z-index: 10000; box-shadow: 0 0 15px rgba(0,0,0,0.3); font-family: sans-serif;">
          <h4 style="margin-top: 0;">Edit Line Group</h4>
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label style="width: 130px;">Number of lines</label>
            <input type="range" id="a1_edit_num_lines" min="1" max="20" value="3" style="flex: 1;">
            <span id="a1_num_lines_val" style="width: 30px; text-align: right;">3</span>
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label style="width: 130px;">Spacing (px)</label>
            <input type="range" id="a1_edit_spacing" min="5" max="100" value="20" style="flex: 1;">
            <span id="a1_spacing_val" style="width: 30px; text-align: right;">20</span>
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label style="width: 130px;">Width (px)</label>
            <input type="range" id="a1_edit_width" min="10" max="800" value="100" style="flex: 1;">
            <span id="a1_width_val" style="width: 40px; text-align: right;">100</span>
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label style="width: 130px;">Thickness (px)</label>
            <input type="range" id="a1_edit_thickness" min="1" max="10" value="2" style="flex: 1;">
            <span id="a1_thickness_val" style="width: 40px; text-align: right;">2</span>
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label style="width: 130px;">Color</label>
            <input type="color" id="a1_edit_color" value="#000000">
          </div>

          <div style="margin-top: 15px; text-align: right;">
          <button id="a1_delete_group" class="small-button delete-button">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
              Trash
            </button>
            
            <button id="a1-duplicate-lineset" class="small-button duplicate-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M8 2h8v8H8V2zm8 14h8v8h-8v-8z"/></svg>
              Clone
            </button>
            <button id="a1_cancel_edit" class="small-button done-button">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
              Done 
            </button>
          </div>
        </div>

1. a1_lineset definition inside lumise: {}. Here is the code below:
"a1_lineset": function (ops, callback) {
          const lines = [];

          if (Array.isArray(ops.objects)) {
            ops.objects.forEach(obj => {
              const line = new fabric.Line([obj.x1, obj.y1, obj.x2, obj.y2], {
                ...obj, // preserve all original properties
                stroke: obj.stroke || obj.fill || '#000000', // prefer stroke, fallback to fill or black
                strokeWidth: obj.strokeWidth || 2,
                left: obj.left,
                top: obj.top,
                originX: obj.originX || 'center',
                originY: obj.originY || 'center',
                opacity: obj.opacity !== undefined ? obj.opacity : 1,
                visible: obj.visible !== false,
                selectable: false,
                evented: false,
              });
              lines.push(line);
            });
          }

          const group = new fabric.Group(lines, {
            left: ops.left,
            top: ops.top,
            originX: ops.originX || 'center',
            originY: ops.originY || 'center',
            type: 'a1_lineset',
            name: ops.name || 'Line Set',
            angle: ops.angle || 0,
            scaleX: ops.scaleX || 1,
            scaleY: ops.scaleY || 1,
            selectable: true,
            evented: true,
            opacity: ops.opacity !== undefined ? ops.opacity : 1,
            visible: ops.visible !== false,
            metadata: ops.metadata || {},
            // üö´ DO NOT set group-level fill/stroke
          });

          console.log('‚úÖ Reconstructed a1_lineset group with', lines.length, 'lines:', group);

          callback(group);
        },
    
2. custom fabric class definition [just before lumise.init(lumise.data.lumise_app_nonce);]

  // 1. Define your custom class
  // Define your custom group class correctly
  fabric.A1LineSet = fabric.util.createClass(fabric.Group, {
    type: 'a1_lineset',

    initialize: function (objects, options) {
      options = options || {};
      this.callSuper('initialize', objects, options);
      this.set({
        id: options.id || '',
        metadata: options.metadata || {}
      });
    },

    toObject: function (propertiesToInclude) {
      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
        id: this.id,
        metadata: this.metadata
      });
    }
  });

  fabric.A1LineSet.fromObject = function (object, callback) {
    console.log("üåÄ Rehydrating A1LineSet", object);

    fabric.util.enlivenObjects(object.objects, function (enlivenedObjects) {
      const options = fabric.util.object.clone(object);
      delete options.objects;

      const group = new fabric.A1LineSet(enlivenedObjects, options);
      callback && callback(group);
    });
  };

  // ‚úÖ This is the key to make Lumise recognize the type
  fabric['a1_lineset'] = fabric.A1LineSet;

  3. Wait for Lumise to load [may be there is nothing to update this one anymore]: 

  (function waitForLumiseCanvas(attempts = 0) {
    try {
      if (
        typeof lumise !== 'undefined' &&
        typeof lumise.stage === 'function' &&
        lumise.stage() &&
        lumise.stage().canvas
      ) {
        const canvas = lumise.stage().canvas;

        // ‚úÖ Extend Group.toObject for custom metadata persistence
        const origGroupToObject = fabric.Group.prototype.toObject;
        fabric.Group.prototype.toObject = function (propertiesToInclude = []) {
          const base = origGroupToObject.call(this, propertiesToInclude);
          if (this.name?.startsWith('a1_')) {
            base.metadata = this.metadata;
            base.object_type = this.object_type;
            base.object_id = this.object_id;
          }
          return base;
        };

        // ‚úÖ Extend Group.fromObject to reconstruct custom groups
        const origGroupFromObject = fabric.Group.fromObject;
        fabric.Group.fromObject = function (object, callback) {
          if (object.object_type === 'a1_lineset') {
            const group = createOrUpdateLineset(object.metadata, true);
            callback?.(group);
            return group;
          }

          if (object.object_type === 'a1_dottedgrid') {
            const group = createOrUpdateDottedGrid(object.metadata, true);
            callback?.(group);
            return group;
          }

          return origGroupFromObject.call(this, object, callback);
        };

        console.log("‚úÖ Lumise canvas is ready");

        // üéØ Continue with your UI logic
        initA1Designer(canvas);

      } else {
        throw new Error("Lumise canvas/hooks not ready");
      }
    } catch (err) {
      if (attempts < 50) {
        setTimeout(() => waitForLumiseCanvas(attempts + 1), 100);
      } else {
        console.error("‚ùå Failed to initialize after waiting:", err);
      }
    }
  })();

  4. createOrUpdateLinesets and createOrUpdatedotGrids. What I have right now for createOrUpdateLinesets is this: 

  function createOrUpdateLineset(meta, isEdit = false) {
    const canvas = lumise.stage().canvas;

    // üßπ Remove previous group if any
    if (window._a1_active_group && canvas.contains(window._a1_active_group)) {
      canvas.remove(window._a1_active_group);
    }

    const lines = [];

    for (let i = 0; i < meta.numLines; i++) {
      lines.push(new fabric.Line([0, i * meta.spacing, meta.width, i * meta.spacing], {
        stroke: meta.color,
        strokeWidth: meta.thickness || 2,
        originX: 'center',
        originY: 'center',
        selectable: false,
        evented: false
      }));
    }

    const limit = lumise.stage().limit_zone;
    const x = limit.left + limit.width / 2;
    const y = limit.top + limit.height / 2;

    const group = new fabric.Group(lines, {
      left: window._a1_active_group?.left || x,
      top: window._a1_active_group?.top || y,
      originX: 'center',
      originY: 'center',
      name: 'a1_lineset',
      id: 'a1_lineset_' + Date.now(),
      metadata: meta,
      object_type: 'a1_lineset',
      object_id: 'a1_lineset_' + Date.now(),
      selectable: true,
      evented: true
    });

    group.setControlsVisibility({
      mt: false, mb: false, ml: false, mr: false,
      bl: false, br: false, tl: false, tr: false, mtr: false
    });

    group.hasControls = false;
    group.hasBorders = true;

    canvas.add(group);
    canvas.setActiveObject(group);
    canvas.renderAll();

    window._a1_active_group = group;

    return group;
  }

  these need to be incorporated into dotgrids: 

  function createOrUpdateDottedGrid(meta, isEdit = false) {
    const canvas = lumise.stage().canvas;

    if (isEdit && window._a1_active_dotted && canvas.contains(window._a1_active_dotted)) {
      canvas.remove(window._a1_active_dotted);
    }

    const dots = [];
    for (let i = 0; i < meta.rows; i++) {
      const y = i * meta.rowSpacing;
      for (let x = 0; x <= meta.width; x += meta.dotSpacing) {
        dots.push(new fabric.Circle({
          left: x,
          top: y,
          radius: meta.dotRadius,
          fill: meta.dotColor,
          originX: 'left',
          originY: 'top'
        }));
      }
    }

    const limit = lumise.stage().limit_zone;
    const x = window._a1_active_dotted?.left || limit.left + limit.width / 2;
    const y = window._a1_active_dotted?.top || limit.top + limit.height / 2;

    const group = new fabric.Group(dots, {
      left: x,
      top: y,
      originX: 'center',
      originY: 'center',
      name: 'a1_dottedgrid',
      id: 'a1_dotted_' + Date.now(),
      metadata: meta,
      object_type: 'a1_dottedgrid',
      object_id: 'a1-dotted-' + Date.now()
    });

    group.setControlsVisibility({
      mt: false, mb: false, ml: false, mr: false,
      bl: false, br: false, tl: false, tr: false, mtr: false
    });

    group.hasControls = false;
    group.hasBorders = false;

    canvas.add(group);
    canvas.setActiveObject(group);
    canvas.renderAll();

    window._a1_active_dotted = group;

    return group;
  }

  5. Live Editing code: 

  for a1_lineset its this code thats working:

  ['num_lines', 'spacing', 'width', 'color', 'thickness'].forEach(field => {
    const input = document.getElementById(`a1_edit_${field}`);
    const output = document.getElementById(`a1_${field}_val`);

    input?.addEventListener('input', () => {
      if (output && input.type === 'range') {
        output.textContent = input.value;
      }

      const meta = {
        numLines: parseInt(document.getElementById("a1_edit_num_lines")?.value || "0", 10),
        spacing: parseInt(document.getElementById("a1_edit_spacing")?.value || "0", 10),
        width: parseInt(document.getElementById("a1_edit_width")?.value || "0", 10),
        color: document.getElementById("a1_edit_color")?.value || "#000000",
        thickness: parseInt(document.getElementById("a1_edit_thickness")?.value || "2", 10)
      };

      if (
        meta.numLines > 0 &&
        meta.spacing > 0 &&
        meta.width > 0 &&
        meta.color &&
        meta.thickness > 0 &&
        window._a1_active_group
      ) {
        createOrUpdateLineset(meta, true); // isEdit = true
      }
    });
  });

  Need to change dotgrids live Editing: 

  ['rows', 'row_spacing', 'width', 'spacing', 'radius'].forEach(suffix => {
    const input = document.getElementById(`a1_edit_dotted_${suffix}`);
    const output = document.getElementById(`a1_edit_dotted_${suffix}_val`);

    input?.addEventListener('input', () => {
      if (output && input.type === 'range') {
        output.textContent = input.value;
      }

      const meta = {
        rows: parseInt(document.getElementById("a1_edit_dotted_rows")?.value || "0", 10),
        rowSpacing: parseInt(document.getElementById("a1_edit_dotted_row_spacing")?.value || "0", 10),
        width: parseInt(document.getElementById("a1_edit_dotted_width")?.value || "0", 10),
        dotSpacing: parseInt(document.getElementById("a1_edit_dotted_spacing")?.value || "0", 10),
        dotRadius: parseInt(document.getElementById("a1_edit_dotted_radius")?.value || "0", 10),
        dotColor: document.getElementById("a1_edit_dotted_color")?.value || "#000000"
      };

      if (
        meta.rows > 0 &&
        meta.rowSpacing > 0 &&
        meta.width > 0 &&
        meta.dotSpacing > 0 &&
        meta.dotRadius > 0 &&
        meta.dotColor &&
        window._a1_active_dotted
      ) {
        createOrUpdateDottedGrid(meta, true); // Live update
      }
    });
  });

  NOTE: color input for dot grid was giving some problem so we had a special function for it: 

  const colorInput = document.getElementById("a1_edit_dotted_color");
    colorInput?.addEventListener("input", () => {
      const meta = {
        rows: parseInt(document.getElementById("a1_edit_dotted_rows")?.value || "0", 10),
        rowSpacing: parseInt(document.getElementById("a1_edit_dotted_row_spacing")?.value || "0", 10),
        width: parseInt(document.getElementById("a1_edit_dotted_width")?.value || "0", 10),
        dotSpacing: parseInt(document.getElementById("a1_edit_dotted_spacing")?.value || "0", 10),
        dotRadius: parseInt(document.getElementById("a1_edit_dotted_radius")?.value || "0", 10),
        dotColor: colorInput.value
      };

      if (
        meta.rows > 0 &&
        meta.rowSpacing > 0 &&
        meta.width > 0 &&
        meta.dotSpacing > 0 &&
        meta.dotRadius > 0 &&
        meta.dotColor &&
        window._a1_active_dotted
      ) {
        createOrUpdateDottedGrid(meta, true);
      }
    });

  6. We decided to show edit modal directly without showing create modal and add object to canvas: 

  document.getElementById("a1_lines")?.addEventListener("click", function () {
    // const defaultMeta = {
    //   numLines: 3,
    //   spacing: 20,
    //   width: 100,
    //   color: "#000000"
    // };
    const defaultMeta = {
      numLines: 3,
      spacing: 20,
      width: 100,
      color: "#000000",
      thickness: 2
    };

    document.getElementById("a1_edit_thickness").value = defaultMeta.thickness;
    document.getElementById("a1_thickness_val").textContent = defaultMeta.thickness;


    // Pre-fill edit modal with new values
    document.getElementById("a1_edit_num_lines").value = defaultMeta.numLines;
    document.getElementById("a1_edit_spacing").value = defaultMeta.spacing;
    document.getElementById("a1_edit_width").value = defaultMeta.width;
    document.getElementById("a1_edit_color").value = defaultMeta.color;

    // Show modal
    document.getElementById("a1_modal_overlay").style.display = "block";
    document.getElementById("a1_edit_form").style.display = "block";

    // ‚úÖ Actually create a new instance (DO NOT remove any group)
    const lines = [];
    for (let i = 0; i < defaultMeta.numLines; i++) {
      lines.push(new fabric.Line([0, i * defaultMeta.spacing, defaultMeta.width, i * defaultMeta.spacing], {
        stroke: defaultMeta.color,
        strokeWidth: 2
      }));
    }

    const limit = lumise.stage().limit_zone;
    const canvas = lumise.stage().canvas;

    const group = new fabric.A1LineSet(lines, {
      left: limit.left + limit.width / 2,
      top: limit.top + limit.height / 2,
      originX: 'center',
      originY: 'center',
      name: 'a1_lineset',
      id: 'a1_lineset_' + Date.now(),
      metadata: defaultMeta
    });

    group.setControlsVisibility({
      mt: false, mb: false, ml: false, mr: false,
      bl: false, br: false, tl: false, tr: false, mtr: false
    });

    group.hasControls = false;
    group.hasBorders = true;

    canvas.add(group);
    canvas.setActiveObject(group);
    canvas.renderAll();

    // üß† Set as active group for editing
    window._a1_active_group = group;
  });

7. on mousedown, i.e on touching the object, the Live Edit modal would popup with prefilled data:

canvas.on('mouse:down', function (e) {
  const target = e.target;
  const editForm = document.getElementById('a1_edit_form');

  if (target && target.name === 'a1_lineset' && target.metadata) {
    window._a1_active_group = target;

    const meta = target.metadata;
    document.getElementById("a1_edit_num_lines").value = meta.numLines || 2;
    document.getElementById("a1_edit_spacing").value = meta.spacing || 20;
    document.getElementById("a1_edit_width").value = meta.width || 100;
    document.getElementById("a1_edit_color").value = meta.color || "#000000";

    document.getElementById("a1_modal_overlay").style.display = "block";
    editForm.style.display = "block";

    console.log("üõ†Ô∏è Edit modal opened for", meta);
  } else {
    window._a1_active_group = null;
    editForm.style.display = "none";
    document.getElementById("a1_modal_overlay").style.display = "none";
  }
});

8. Delete function
document.getElementById("a1_delete_group").onclick = function () {
  const group = window._a1_active_group;
  if (!group) return;

  canvas.remove(group);
  canvas.renderAll();
  window._a1_active_group = null;
  document.getElementById("a1_edit_form").style.display = "none";
};

9. Duplicate function
document.getElementById('a1-duplicate-lineset').addEventListener('click', function () {
  if (!window._a1_active_group || !window._a1_active_group.metadata) {
    alert("No active lineset to duplicate.");
    return;
  }

  const originalMeta = window._a1_active_group.metadata;

  // Create a shallow copy of metadata and give it a new ID
  const newMeta = {
    ...originalMeta,
    // Optional: tweak if needed
  };

  // Offset the new group a bit
  const limit = lumise.stage().limit_zone;
  const x = (window._a1_active_group.left || limit.left) + 40;
  const y = (window._a1_active_group.top || limit.top) + 40;

  // Assign new metadata ID
  const newId = 'a1_lineset_' + Date.now();
  newMeta.object_id = newId;

  const canvas = lumise.stage().canvas;

  const lines = [];
  for (let i = 0; i < newMeta.numLines; i++) {
    lines.push(new fabric.Line([0, i * newMeta.spacing, newMeta.width, i * newMeta.spacing], {
      stroke: newMeta.color,
      strokeWidth: newMeta.thickness || 2
    }));
  }

  const group = new fabric.Group(lines, {
    left: x,
    top: y,
    originX: 'center',
    originY: 'center',
    name: 'a1_lineset',
    id: newId,
    metadata: newMeta,
    object_type: 'a1_lineset',
    object_id: newId,
    selectable: true,
    evented: true
  });

  group.setControlsVisibility({
    mt: false, mb: false, ml: false, mr: false,
    bl: false, br: false, tl: false, tr: false, mtr: false
  });

  group.hasControls = false;
  group.hasBorders = false;

  canvas.add(group);
  canvas.setActiveObject(group);
  canvas.renderAll();

  // Update global reference
  window._a1_active_group = group;

  alert('‚úÖ Line group duplicated!');
});

9. Load function need to be modified to include your new custom object. something like this: 

const fixCustomTypes = (data) => {
  const objs = data?.stages?.lumise?.data?.objects || [];
  objs.forEach(obj => {
    if (obj.object_type === 'a1_lineset' && obj.type === 'group') {
      console.log('üîß Fixing group to type a1_lineset before import');
      obj.type = 'a1_lineset';
    }

    if (obj.object_type === 'a1_dotgrid' && obj.type === 'group') {
      console.log('üîß Fixing group to type a1_dotgrid before import');
      obj.type = 'a1_dotgrid';
    }
  });
};

10. color input for grid - fill - old code below
const colorInput = document.getElementById("a1_edit_dotted_color");
    colorInput?.addEventListener("input", () => {
      const meta = {
        rows: parseInt(document.getElementById("a1_edit_dotted_rows")?.value || "0", 10),
        rowSpacing: parseInt(document.getElementById("a1_edit_dotted_row_spacing")?.value || "0", 10),
        width: parseInt(document.getElementById("a1_edit_dotted_width")?.value || "0", 10),
        dotSpacing: parseInt(document.getElementById("a1_edit_dotted_spacing")?.value || "0", 10),
        dotRadius: parseInt(document.getElementById("a1_edit_dotted_radius")?.value || "0", 10),
        dotColor: colorInput.value
      };

      if (
        meta.rows > 0 &&
        meta.rowSpacing > 0 &&
        meta.width > 0 &&
        meta.dotSpacing > 0 &&
        meta.dotRadius > 0 &&
        meta.dotColor &&
        window._a1_active_dotted
      ) {
        createOrUpdateDottedGrid(meta, true);
      }
    });

    //updated code
    const a1_dotgrid_colorInput = document.getElementById("a1_edit_dot_color");
    a1_dotgrid_colorInput?.addEventListener("input", () => {

        const meta = {
            rows: parseInt(document.getElementById("a1_edit_rows")?.value || "0", 10),
            cols: parseInt(document.getElementById("a1_edit_cols")?.value || "0", 10),
            spacingX: parseInt(document.getElementById("a1_edit_spacing_x")?.value || "0", 10),
            spacingY: parseInt(document.getElementById("a1_edit_spacing_y")?.value || "0", 10),
            radius: parseFloat(document.getElementById("a1_edit_dot_radius")?.value || "2"),
            color: a1_dotgrid_colorInput.value
          };

      if (
        meta.rows > 0 &&
        meta.rowSpacing > 0 &&
        meta.width > 0 &&
        meta.dotSpacing > 0 &&
        meta.dotRadius > 0 &&
        meta.dotColor &&
        window._a1_active_dotted
      ) {
        createOrUpdateDotGrid(meta, true);
      }
    });
